import OpenGL.GL as gl
import numpy as np
import math
import random
import sys

from fileloader import ObjLoader
from geometry.vec3 import Vec3
from geometry.face import Face
from geometry.ray import Ray
from formulas.db_formulas import drop_off, sum_levels, db_to_color
from raytracing.brdf import generate_brdf
from geometry.materials import Materials as mtl


class RayTracer:
    def __init__(
        self,
        origin: Vec3,
        ray_num: int,
        faces: np.ndarray,
        start_db=120.0,
        freq=1000,
        reflections=0,
    ):
        self.origin = origin
        self.ray_num = ray_num
        self.faces = faces
        self.start_db = start_db
        self.freq = freq
        self.point_dict = dict()

        for ray in self.generate_rays():
            success = self.intersect(ray, reflections)
            if not success:
                print("Error")

    def render(self):
        """
        Returns a renderable calllist of the points generated by raytracing the model.
        """
        gl_list = gl.glGenLists(1)
        gl.glNewList(gl_list, gl.GL_COMPILE)
        gl.glShadeModel(gl.GL_SMOOTH)
        gl.glPointSize(5)
        gl.glBegin(gl.GL_POINTS)
        for vec, dB in sorted(
            self.point_dict.items(), key=lambda item: item[1], reverse=True
        ):
            if dB > 100:
                gl.glColor4f(*db_to_color(dB), 1)
            elif dB > 80:
                gl.glColor4f(*db_to_color(dB), 0.65)
            elif dB > 60:
                gl.glColor4f(*db_to_color(dB), 0.25)
            elif dB > 40:
                gl.glColor4f(*db_to_color(dB), 0.125)
            else:
                gl.glColor4f(*db_to_color(dB), 0.0625)

            gl.glVertex3fv(vec)
        gl.glEnd()
        gl.glEndList()
        return gl_list

    def generate_rays(self) -> list:
        """
        Generates an array of rays to use for the raytracing
        """
        rnd = random.random() * self.ray_num

        points = []
        offset = 2.0 / self.ray_num
        increment = math.pi * (3.0 - math.sqrt(5.0))

        for i in range(self.ray_num):
            y = ((i * offset) - 1) + (offset / 2)
            r = math.sqrt(1 - pow(y, 2))

            phi = ((i + rnd) % self.ray_num) * increment

            x = math.cos(phi) * r
            z = math.sin(phi) * r

            points.append(Ray(self.origin, Vec3(x, y, z).normalize(), 1, self.start_db))
        return points

    def intersect(self, ray: Ray, rNum=0) -> bool:
        """
        Determines the intersection point of the given ray for the current model
        """
        EPSILON = sys.float_info.epsilon
        for face in self.faces:
            # Origin in plane
            if self.is_inside(ray.origin, *face.vertices, face.normal):
                continue

            # Check if ray is parallel to plane
            pvec = ray.direction.cross(face.edge2)
            det = face.edge1.dot(pvec)
            if det > -EPSILON and det < EPSILON:
                continue

            inv_det = 1.0 / det
            tvec = ray.origin.sub(face.vertices[0])
            u = tvec.dot(pvec) * inv_det
            if u < 0.0 or u > 1.0:
                continue

            qvec = tvec.cross(face.edge1)
            v = ray.direction.dot(qvec) * inv_det
            if v < 0.0 or u + v > 1.0:
                continue

            # Distance from ray origin
            t = face.edge2.dot(qvec) * inv_det
            # Ray moves away from the plane
            if t < EPSILON:
                continue

            # Intersection point
            phit_long = ray.origin.add(Vec3(*(ray.direction * t)))
            phit = Vec3(*np.around(phit_long.vec, decimals=2))

            # Calcualate the dB level at the intersection
            new_dist_from_origin = ray.dist_from_origin + ray.origin.distance(phit)
            db_change = drop_off(ray.dist_from_origin, new_dist_from_origin)
            point_db = ray.start_db - db_change

            # Log Point
            curr_point_db = self.point_dict.get((phit.x, phit.y, phit.z))
            if curr_point_db is not None:
                self.point_dict[(phit.x, phit.y, phit.z)] = sum_levels(
                    [point_db, curr_point_db]
                )
            else:
                self.point_dict[(phit.x, phit.y, phit.z)] = point_db

            if rNum > 0:
                # Calculate the reflected rays
                reflected_db = point_db * (1 - mtl.absorption(face.material, self.freq))
                reflections = generate_brdf(
                    ray, phit, reflected_db, new_dist_from_origin, face
                )

                for ray in reflections:
                    if ray.start_db > 0:
                        self.intersect(ray, rNum - 1)

            return True
        return False

    def is_inside(
        self, point: Vec3, v0: Vec3, v1: Vec3, v2: Vec3, normal: Vec3
    ) -> bool:
        """
        Determines if the point is inside the given triangle bounds and on the same plane
        """
        edge0 = v1.sub(v0)
        edge1 = v2.sub(v1)
        edge2 = v0.sub(v2)
        C0 = point.sub(v0)
        C1 = point.sub(v1)
        C2 = point.sub(v2)

        if (
            normal.dot(edge0.cross(C0)) >= 0
            and normal.dot(edge1.cross(C1)) >= 0
            and normal.dot(edge2.cross(C2)) >= 0
            and C0.dot(C1.cross(C2)) == 0.0
        ):
            return True
        return False
